import logging
import random
from datetime import datetime, timedelta

from aiogram import Bot, Dispatcher, executor, types
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton

from tasks import tasks  # –¢–≤–æ—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –∑–∞–≤–¥–∞–Ω—å –∑ —Ä—ñ–≤–Ω—è–º–∏

API_TOKEN = '7808304545:AAEagMXlNfvHd3zG-w21uJHKcEznjaaIJRM'  # üîÅ –ó–∞–º—ñ–Ω–∏—Ç–∏ –Ω–∞ —Å–≤—ñ–π —Ç–æ–∫–µ–Ω

logging.basicConfig(level=logging.INFO)

bot = Bot(token=API_TOKEN)
dp = Dispatcher(bot)

users = {}
active_games = {}

def main_keyboard(has_active_task: bool):
    """
    –§–æ—Ä–º—É—î –≥–æ–ª–æ–≤–Ω–µ –º–µ–Ω—é.
    –Ø–∫—â–æ —î –∞–∫—Ç–∏–≤–Ω–µ –∑–∞–≤–¥–∞–Ω–Ω—è, –¥–æ–¥–∞—î–º–æ –∫–Ω–æ–ø–∫—É '–ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è'
    """
    keyboard = ReplyKeyboardMarkup(resize_keyboard=True)
    buttons = [
        KeyboardButton("–†–µ—î—Å—Ç—Ä–∞—Ü—ñ—è"),
        KeyboardButton("–ú—ñ–π ID"),
        KeyboardButton("–ó–∞–ø—Ä–æ—Å–∏—Ç–∏ –ø–∞—Ä—Ç–Ω–µ—Ä–∞"),
        KeyboardButton("–û—Ç—Ä–∏–º–∞—Ç–∏ –∑–∞–≤–¥–∞–Ω–Ω—è"),
        KeyboardButton("–ü—Ä–æ–ø—É—Å—Ç–∏—Ç–∏ –∑–∞–≤–¥–∞–Ω–Ω—è"),
        KeyboardButton("–†–∞—Ö—É–Ω–æ–∫"),
        KeyboardButton("–°—Ç–∞—Ç—É—Å"),
    ]
    if has_active_task:
        buttons.insert(4, KeyboardButton("–ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è"))
    keyboard.add(*buttons)
    return keyboard

def get_remaining_tasks():
    all_assigned = set()
    for user in users.values():
        for t in user['accepted_tasks']:
            all_assigned.add(t['text'])
        if user['current_task']:
            all_assigned.add(user['current_task']['text'])
    total_tasks = sum(len(v) for v in tasks.values())
    return total_tasks - len(all_assigned)

@dp.message_handler(commands=['start', 'register'])
async def register(message: types.Message):
    user_id = message.from_user.id
    if user_id not in users:
        users[user_id] = {
            'name': message.from_user.first_name,
            'score': 0,
            'current_task': None,
            'skips': 0,
            'partner': None,
            'accepted_tasks': [],
        }
        await message.answer(
            f"–í—ñ—Ç–∞—é, {message.from_user.first_name}! –¢–µ–±–µ –∑–∞—Ä–µ—î—Å—Ç—Ä–æ–≤–∞–Ω–æ —É –≥—Ä—ñ ‚ù§Ô∏è\n"
            f"–¢–≤—ñ–π Telegram ID: `{user_id}`\n"
            "–ü–µ—Ä–µ–¥–∞–π —Ü–µ–π ID –ø–∞—Ä—Ç–Ω–µ—Ä—É, —â–æ–± –≤—ñ–Ω –∑–∞–ø—Ä–æ—Å–∏–≤ —Ç–µ–±–µ –¥–æ –≥—Ä–∏:\n"
            "`/invite <—Ç–≤—ñ–π_ID>`",
            parse_mode="Markdown",
            reply_markup=main_keyboard(has_active_task=False)
        )
    else:
        has_task = users[user_id]['current_task'] is not None
        await message.answer("–¢–∏ –≤–∂–µ –∑–∞—Ä–µ—î—Å—Ç—Ä–æ–≤–∞–Ω–∏–π —É –≥—Ä—ñ.", reply_markup=main_keyboard(has_active_task=has_task))

@dp.message_handler(lambda message: message.text == "–ú—ñ–π ID")
async def show_my_id(message: types.Message):
    user_id = message.from_user.id
    has_task = users.get(user_id, {}).get('current_task') is not None
    await message.answer(f"–¢–≤—ñ–π Telegram ID: `{user_id}`", parse_mode="Markdown", reply_markup=main_keyboard(has_active_task=has_task))

@dp.message_handler(lambda message: message.text == "–ó–∞–ø—Ä–æ—Å–∏—Ç–∏ –ø–∞—Ä—Ç–Ω–µ—Ä–∞")
async def invite_partner_handler(message: types.Message):
    await message.answer("–í–≤–µ–¥–∏ –∫–æ–º–∞–Ω–¥—É —É —Ñ–æ—Ä–º–∞—Ç—ñ:\n/invite <ID –ø–∞—Ä—Ç–Ω–µ—Ä–∞>", reply_markup=main_keyboard(has_active_task=users.get(message.from_user.id, {}).get('current_task') is not None))

@dp.message_handler(commands=['invite'])
async def invite_partner(message: types.Message):
    inviter_id = message.from_user.id
    args = message.get_args()
    if not args.isdigit():
        await message.answer("–í–≤–µ–¥–∏ ID –ø–∞—Ä—Ç–Ω–µ—Ä–∞, –Ω–∞–ø—Ä–∏–∫–ª–∞–¥: /invite 123456789", reply_markup=main_keyboard(has_active_task=users.get(inviter_id, {}).get('current_task') is not None))
        return

    partner_id = int(args)
    if partner_id not in users:
        await message.answer("–¶–µ–π ID –Ω–µ –∑–∞—Ä–µ—î—Å—Ç—Ä–æ–≤–∞–Ω–æ.", reply_markup=main_keyboard(has_active_task=users.get(inviter_id, {}).get('current_task') is not None))
        return

    if users[inviter_id]['partner'] or users[partner_id]['partner']:
        await message.answer("–û–¥–∏–Ω —ñ–∑ –≥—Ä–∞–≤—Ü—ñ–≤ –≤–∂–µ –º–∞—î –ø–∞—Ä—Ç–Ω–µ—Ä–∞.", reply_markup=main_keyboard(has_active_task=users.get(inviter_id, {}).get('current_task') is not None))
        return

    users[inviter_id]['partner'] = partner_id
    users[partner_id]['partner'] = inviter_id
    active_games[frozenset([inviter_id, partner_id])] = True
    await message.answer("–ì—Ä—É —Å—Ç–≤–æ—Ä–µ–Ω–æ! –ü–æ—á–Ω—ñ—Ç—å –≥—Ä—É –∫–Ω–æ–ø–∫–æ—é '–û—Ç—Ä–∏–º–∞—Ç–∏ –∑–∞–≤–¥–∞–Ω–Ω—è'", reply_markup=main_keyboard(has_active_task=users.get(inviter_id, {}).get('current_task') is not None))

    try:
        await bot.send_message(partner_id, f"{users[inviter_id]['name']} –∑–∞–ø—Ä–æ—Å–∏–≤ —Ç–µ–±–µ –¥–æ –≥—Ä–∏. –ü–æ—á–Ω—ñ—Ç—å –≥—Ä—É –∫–Ω–æ–ø–∫–æ—é '–û—Ç—Ä–∏–º–∞—Ç–∏ –∑–∞–≤–¥–∞–Ω–Ω—è'.", reply_markup=main_keyboard(has_active_task=users.get(partner_id, {}).get('current_task') is not None))
    except Exception:
        pass

@dp.message_handler(lambda message: message.text == "–û—Ç—Ä–∏–º–∞—Ç–∏ –∑–∞–≤–¥–∞–Ω–Ω—è")
async def send_task(message: types.Message):
    user_id = message.from_user.id
    user = users.get(user_id)
    has_task = user['current_task'] is not None if user else False

    if not user or not user['partner']:
        await message.answer("–¢–∏ –Ω–µ –≤ –ø–∞—Ä—ñ. –ó–∞—Ä–µ—î—Å—Ç—Ä—É–π—Å—è /register –∞–±–æ –∑–∞–ø—Ä–æ—Å–∏ –ø–∞—Ä—Ç–Ω–µ—Ä–∞ /invite <ID>", reply_markup=main_keyboard(has_active_task=has_task))
        return

    if has_task:
        await message.answer("–£ —Ç–µ–±–µ –≤–∂–µ —î –∞–∫—Ç–∏–≤–Ω–µ –∑–∞–≤–¥–∞–Ω–Ω—è. –°–ø–æ—á–∞—Ç–∫—É –≤–∏–∫–æ–Ω–∞–π –π–æ–≥–æ –∞–±–æ –ø—Ä–æ–ø—É—Å—Ç–∏.", reply_markup=main_keyboard(has_active_task=True))
        return

    all_assigned = set()
    for u in users.values():
        if u['current_task']:
            all_assigned.add(u['current_task']['text'])
        for t in u['accepted_tasks']:
            all_assigned.add(t['text'])

    all_tasks_list = []
    for level, arr in tasks.items():
        for text in arr:
            all_tasks_list.append({'text': text, 'level': level})

    available_tasks = [t for t in all_tasks_list if t['text'] not in all_assigned]

    if not available_tasks:
        await message.answer("–£—Å—ñ –∑–∞–≤–¥–∞–Ω–Ω—è –≤–∏–∫–æ–Ω–∞–Ω–æ üéâ", reply_markup=main_keyboard(has_active_task=False))
        return

    task = random.choice(available_tasks)
    duration_days = 1 if task['level'] == 'easy' else 3 if task['level'] == 'medium' else 7
    deadline = datetime.now() + timedelta(days=duration_days)

    user['current_task'] = {'text': task['text'], 'deadline': deadline, 'level': task['level']}

    partner_id = user['partner']

    await message.answer(
        f"üìù –ó–∞–≤–¥–∞–Ω–Ω—è ({task['level']} —Ä—ñ–≤–µ–Ω—å):\n{task['text']}\n"
        f"‚è∞ –¢–µ—Ä–º—ñ–Ω –≤–∏–∫–æ–Ω–∞–Ω–Ω—è: {duration_days} –¥–Ω—ñ–≤\n\n"
        "–ù–∞—Ç–∏—Å–Ω–∏ '–ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è', –∫–æ–ª–∏ –≤–∏–∫–æ–Ω–∞—î—à –∑–∞–≤–¥–∞–Ω–Ω—è.",
        reply_markup=main_keyboard(has_active_task=True)
    )

    try:
        await bot.send_message(partner_id, f"{user['name']} –æ—Ç—Ä–∏–º–∞–≤ –Ω–æ–≤–µ –∑–∞–≤–¥–∞–Ω–Ω—è: {task['text']}", reply_markup=main_keyboard(has_active_task=users.get(partner_id, {}).get('current_task') is not None))
    except Exception:
        pass

@dp.message_handler(lambda message: message.text == "–ü—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è")
async def accept_task(message: types.Message):
    user_id = message.from_user.id
    user = users.get(user_id)
    if not user or not user['current_task']:
        await message.answer("–ù–µ–º–∞—î –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∑–∞–≤–¥–∞–Ω–Ω—è –¥–ª—è –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è.", reply_markup=main_keyboard(has_active_task=False))
        return

    task_text = user['current_task']['text']
    level = user['current_task']['level']
    points_map = {'easy': 1, 'medium': 2, 'hard': 3, 'bonus': 5}
    user['accepted_tasks'].append(user['current_task'])
    user['current_task'] = None
    user['skips'] = 0
    user['score'] += points_map.get(level, 1)

    await message.answer(f"‚úÖ –ó–∞–≤–¥–∞–Ω–Ω—è –ø—Ä–∏–π–Ω—è—Ç–æ: {task_text}\n+{points_map.get(level,1)} –±–∞–ª—ñ–≤", reply_markup=main_keyboard(has_active_task=False))

    partner_id = user['partner']
    if partner_id:
        await bot.send_message(partner_id, f"{user['name']} –ø—Ä–∏–π–Ω—è–≤ –∑–∞–≤–¥–∞–Ω–Ω—è: {task_text}", reply_markup=main_keyboard(has_active_task=users.get(partner_id, {}).get('current_task') is not None))

@dp.message_handler(lambda message: message.text == "–ü—Ä–æ–ø—É—Å—Ç–∏—Ç–∏ –∑–∞–≤–¥–∞–Ω–Ω—è")
async def skip_task(message: types.Message):
    user_id = message.from_user.id
    user = users.get(user_id)
    has_task = user['current_task'] is not None if user else False

    if not user or not has_task:
        await message.answer("–ù–µ–º–∞—î –∑–∞–≤–¥–∞–Ω–Ω—è –¥–ª—è –ø—Ä–æ–ø—É—Å–∫—É.", reply_markup=main_keyboard(has_active_task=False))
        return

    user['skips'] += 1
    text = user['current_task']['text']
    user['current_task'] = None

    if user['skips'] >= 3:
        user['score'] -= 1
        user['skips'] = 0
        await message.answer("‚ùå 3 –ø—Ä–æ–ø—É—Å–∫–∏ –ø—ñ–¥—Ä—è–¥. -1 –±–∞–ª.", reply_markup=main_keyboard(has_active_task=False))
    else:
        await message.answer(f"–ü—Ä–æ–ø—É—â–µ–Ω–æ –∑–∞–≤–¥–∞–Ω–Ω—è: {text}", reply_markup=main_keyboard(has_active_task=False))

@dp.message_handler(lambda message: message.text == "–†–∞—Ö—É–Ω–æ–∫")
async def show_score(message: types.Message):
    user_id = message.from_user.id
    user = users.get(user_id)
    has_task = user['current_task'] is not None if user else False

    if not user:
        await message.answer("–¢–∏ —â–µ –Ω–µ –≤ –≥—Ä—ñ.", reply_markup=main_keyboard(has_active_task=False))
        return

    partner = users.get(user.get('partner'))
    msg = f"–¢–≤—ñ–π —Ä–∞—Ö—É–Ω–æ–∫: {user['score']} –±–∞–ª—ñ–≤"
    if partner:
        msg += f"\n–†–∞—Ö—É–Ω–æ–∫ –ø–∞—Ä—Ç–Ω–µ—Ä–∞ ({partner['name']}): {partner['score']} –±–∞–ª—ñ–≤"

    await message.answer(msg, reply_markup=main_keyboard(has_active_task=has_task))

@dp.message_handler(lambda message: message.text == "–°—Ç–∞—Ç—É—Å")
async def task_status(message: types.Message):
    user_id = message.from_user.id
    user = users.get(user_id)
    has_task = user['current_task'] is not None if user else False

    if not user:
        await message.answer("–¢–∏ –Ω–µ –∑–∞—Ä–µ—î—Å—Ç—Ä–æ–≤–∞–Ω–∏–π.", reply_markup=main_keyboard(has_active_task=False))
        return

    msg = f"üìä –ó–∞–ª–∏—à–∏–ª–æ—Å—å –∑–∞–≤–¥–∞–Ω—å: {get_remaining_tasks()}"
    if has_task:
        deadline = user['current_task']['deadline']
        time_left = deadline - datetime.now()
        days_left = max(time_left.days, 0)
        msg += f"\nüïì –¢–≤–æ—î –∑–∞–≤–¥–∞–Ω–Ω—è: {user['current_task']['text']}\n–ó–∞–ª–∏—à–∏–ª–æ—Å—å: {days_left} –¥–Ω—ñ–≤"
    else:
        msg += "\n–£ —Ç–µ–±–µ –Ω–µ–º–∞—î –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –∑–∞–≤–¥–∞–Ω–Ω—è."

    await message.answer(msg, reply_markup=main_keyboard(has_active_task=has_task))

if __name__ == '__main__':
    executor.start_polling(dp, skip_updates=True)
